# OSSF Scorecard Analysis workflow
# - Trigger: workflow_dispatch with input "repo" (owner/repo or full URL) and optional "checks".
# - Runs the OpenSSF Scorecard Docker image (gcr.io/openssf/scorecard:stable) on an Ubuntu runner.
# - Produces a JSON result at ossf-scorecard-output/scorecard.json and uploads it as an artifact.
# - Job outputs: artifact_name, aggregate_score, analysis_b64 (base64 JSON if small enough; analysis_truncated=true otherwise).
# - How to run: from the Actions tab, start the workflow and provide repo = owner/repo (or full GitHub URL).
# - For higher rate limits or private repos, set repository secret SCORECARD_TOKEN (falls back to GITHUB_TOKEN).

name: OSSF Scorecard Analysis

on:
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository to analyze (owner/repo or full URL)'
        required: true
        default: ''
      id: 
        description: 'Unique identifier for the workflow run (for tracking purposes)'
        required: true
        default: ''
      checks:
        description: 'Comma-separated checks to run (optional)'
        required: false
        default: ''

# read access is required for retrieving repository metadata if using the default GITHUB_TOKEN
permissions:
  contents: read

jobs:
  ossf-scorecard:
    name: Run OSSF Scorecard
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.set-id.outputs.artifact_name }}
      aggregate_score: ${{ steps.run-score.outputs.aggregate_score }}
      analysis_b64: ${{ steps.run-score.outputs.analysis_b64 }}
      artifact_download_url: ${{ steps.get-artifact-url.outputs.download_url }}

    steps:

      - name: Set workflow run ID
        id: set-id
        run: |
          # If the 'id' input is empty or an empty string, set it to a unique GUID
          if [ -z "${{ github.event.inputs.id }}" ] || [ "${{ github.event.inputs.id }}" = "null" ]; then
            # Generate a GUID (UUID v4)
            if command -v uuidgen >/dev/null 2>&1; then
              ID=$(uuidgen)
            else
              ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || (head -c16 /dev/urandom | xxd -p | sed 's/\(..\)/\1-/g; s/-$//'))
            fi
          else
            ID="${{ github.event.inputs.id }}"
          fi

          # Sanitize repo input to a filesystem-safe token for artifact names
          REPO_INPUT_RAW="${{ github.event.inputs.repo }}"
          REPO_PATH="$REPO_INPUT_RAW"
          # strip protocol/host for full URLs (e.g. https://github.com/owner/repo -> owner/repo)
          if echo "$REPO_PATH" | grep -E '^https?://' >/dev/null 2>&1; then
            REPO_PATH=$(echo "$REPO_PATH" | sed -E 's#^https?://[^/]+/##')
          fi
          # strip git@host:owner/repo forms
          if echo "$REPO_PATH" | grep -E '^git@' >/dev/null 2>&1; then
            REPO_PATH=$(echo "$REPO_PATH" | sed -E 's#^git@[^:]+:##')
          fi
          # trim trailing .git if present
          REPO_PATH=$(echo "$REPO_PATH" | sed -E 's#\.git$##')
          # fallback if empty
          if [ -z "$REPO_PATH" ] || [ "$REPO_PATH" = "null" ]; then
            REPO_PATH="unknown_repo"
          fi
          # make filename-safe: replace / and other non-alphanum with _
          REPO_SAFE=$(printf '%s' "$REPO_PATH" | sed -E 's#[/\\ ]#_#g' | sed 's/[^0-9A-Za-z._-]/_/g')

          ARTIFACT_NAME="ossf-scorecard_${REPO_SAFE}_${ID}"

          echo "id=$ID" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
          echo "Workflow run ID: $ID"
          echo "Artifact name: $ARTIFACT_NAME"

          # Add the ID to the step summary
          echo "Workflow run INPUT_GUID_ID: $ID" >> $GITHUB_STEP_SUMMARY

      - name: Restore Scorecard image cache
        id: cache-scorecard-image
        uses: actions/cache@v4
        with:
          path: scorecard_image.tar
          key: scorecard-image-${{ runner.os }}-gcr-ossf-scorecard-stable

      - name: Load cached Scorecard image
        if: steps.cache-scorecard-image.outputs.cache-hit == 'true'
        run: |
          if [ -f scorecard_image.tar ]; then
            echo "Loading cached Scorecard image..."
            docker load -i scorecard_image.tar || true
          else
            echo "Cache indicated hit but tarball missing; proceeding to pull image."
          fi

      - name: Pull and save Scorecard image (cache miss)
        if: steps.cache-scorecard-image.outputs.cache-hit != 'true'
        run: |
          echo "Pulling Scorecard image from registry..."
          docker pull gcr.io/openssf/scorecard:stable
          echo "Saving Scorecard image to tar for caching..."
          docker save gcr.io/openssf/scorecard:stable -o scorecard_image.tar

      - name: Run Scorecard (Docker)
        id: run-score
        # shell step runs on the runner and will pull the Scorecard Docker image
        run: |
          set -euo pipefail

          # Input repository (owner/repo or full URL)
          REPO_INPUT="${{ github.event.inputs.repo }}"
          if [ -z "$REPO_INPUT" ] || [ "$REPO_INPUT" = "null" ]; then
            echo "No repository supplied (workflow input 'repo' is required)." >&2
            exit 1
          fi

          # Normalize the repo argument for scorecard (--repo accepts e.g. github.com/owner/repo or a full URL)
          if echo "$REPO_INPUT" | grep -E '^https?://' >/dev/null 2>&1; then
            REPO_ARG="$REPO_INPUT"
          elif echo "$REPO_INPUT" | grep -E '^[^/]+/[^/]+$' >/dev/null 2>&1; then
            REPO_ARG="https://github.com/$REPO_INPUT"
          else
            echo "Repo input must be 'owner/repo' or a full URL" >&2
            exit 1
          fi

          # Prefer a repo-scoped secret SCORECARD_TOKEN if provided; otherwise fall back to GITHUB_TOKEN
          TOKEN="${{ secrets.SCORECARD_TOKEN }}"
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            TOKEN="${{ secrets.GITHUB_TOKEN }}"
          fi

          # Prepare output directory and file
          OUT_DIR="${{ github.workspace }}/ossf-scorecard-output"
          mkdir -p "$OUT_DIR"
          RESULT_FILE="$OUT_DIR/scorecard_${{ steps.set-id.outputs.id }}.json"

          # Optional: allow caller to provide which checks to run
          CHECKS_INPUT="${{ github.event.inputs.checks }}"
          CHECKS_ARG=""
          if [ -n "$CHECKS_INPUT" ] && [ "$CHECKS_INPUT" != "null" ]; then
            CHECKS_ARG="--checks=${CHECKS_INPUT}"
          fi

          # Pull and run the official Scorecard container. If a token is available, pass it to avoid rate limits.
          DOCKER_ENV_ARGS=()
          if [ -n "$TOKEN" ]; then
            DOCKER_ENV_ARGS+=( -e GITHUB_AUTH_TOKEN="$TOKEN" )
          fi

          echo "Running Scorecard against: $REPO_ARG"
          # Capture stdout and stderr so we can detect and record non-JSON output
          STDERR_FILE="$OUT_DIR/scorecard_${{ steps.set-id.outputs.id }}.stderr.log"
          RESULT_LOG="$OUT_DIR/scorecard_${{ steps.set-id.outputs.id }}.log"
          # Run docker and capture exit code separately so we can log it
          docker run --rm "${DOCKER_ENV_ARGS[@]}" gcr.io/openssf/scorecard:stable --format=json ${CHECKS_ARG} --repo="$REPO_ARG" > "$RESULT_FILE" 2>"$STDERR_FILE"
          DOCKER_EXIT_CODE=$?

          # Write header with timestamp and exit status to the consolidated log
          echo "Timestamp: $(date --utc +%Y-%m-%dT%H:%M:%SZ)" > "$RESULT_LOG" || true
          echo "Docker exit code: ${DOCKER_EXIT_CODE}" >> "$RESULT_LOG" || true

          # Prepare artifact name (start with the base name produced by set-id)
          ARTIFACT_NAME="${{ steps.set-id.outputs.artifact_name }}"

          # Validate JSON before parsing; install jq if needed
          IS_JSON=false
          if command -v jq >/dev/null 2>&1; then
            if jq -e . "$RESULT_FILE" >/dev/null 2>&1; then
              IS_JSON=true
            fi
          else
            sudo apt-get update && sudo apt-get install -y jq
            if jq -e . "$RESULT_FILE" >/dev/null 2>&1; then
              IS_JSON=true
            fi
          fi

          AGG_SCORE=""
          if [ "$IS_JSON" = true ]; then
              AGG_SCORE=$(jq -r '.summary.score // .score // ""' "$RESULT_FILE" || true)

              # If we detected a score, append it to the result filename: score_<value>
              if [ -n "$AGG_SCORE" ]; then
                # sanitize score for filename (replace non-alphanum with _ and dots with _)
                SCORE_SAFE=$(printf '%s' "$AGG_SCORE" | sed 's/[^0-9A-Za-z._-]/_/g' | sed 's/\./_/g')
                NEW_RESULT_FILE="$OUT_DIR/scorecard_${{ steps.set-id.outputs.id }}_score_${SCORE_SAFE}.json"
                if [ -f "$RESULT_FILE" ]; then
                  mv "$RESULT_FILE" "$NEW_RESULT_FILE" || cp "$RESULT_FILE" "$NEW_RESULT_FILE" || true
                else
                  touch "$NEW_RESULT_FILE" || true
                fi
                RESULT_FILE="$NEW_RESULT_FILE"
                # Also append the score to the artifact name so uploaded artifact reflects the score
                ARTIFACT_NAME="${ARTIFACT_NAME}_score_${SCORE_SAFE}"
              fi

              # Base64-encode JSON and set as output only if small enough
              B64=$(base64 --wrap=0 "$RESULT_FILE" || base64 "$RESULT_FILE") || true
            B64_LEN=$(echo -n "$B64" | wc -c || true)
            MAX_OUTPUT_LEN=30000
            if [ -n "$B64" ] && [ "$B64_LEN" -le "$MAX_OUTPUT_LEN" ]; then
              echo "analysis_b64<<EOF" >> "$GITHUB_OUTPUT"
              printf '%s\n' "$B64" >> "$GITHUB_OUTPUT"
              echo "EOF" >> "$GITHUB_OUTPUT"
            else
              echo "analysis_b64=" >> "$GITHUB_OUTPUT"
              echo "analysis_truncated=true" >> "$GITHUB_OUTPUT"
            fi
          else
            # Not JSON: consolidate outputs into a log and skip JSON parsing
            echo "Non-JSON output detected from Scorecard run; saving to $RESULT_LOG"
            cat "$RESULT_FILE" > "$RESULT_LOG" 2>/dev/null || true
            if [ -s "$STDERR_FILE" ]; then
              echo "\n--- STDERR ---\n" >> "$RESULT_LOG"
              cat "$STDERR_FILE" >> "$RESULT_LOG" || true
            fi
            echo "analysis_b64=" >> "$GITHUB_OUTPUT"
            echo "analysis_truncated=true" >> "$GITHUB_OUTPUT"
          fi

          # Export smaller outputs
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
          echo "aggregate_score=$AGG_SCORE" >> "$GITHUB_OUTPUT"
          echo "result_file=$RESULT_FILE" >> "$GITHUB_OUTPUT"

          # Add the Score (or note) to the step summary
          if [ "$IS_JSON" = true ]; then
            echo "$REPO_INPUT score: $AGG_SCORE" >> $GITHUB_STEP_SUMMARY
          else
            echo "$REPO_INPUT: Scorecard did not produce JSON; see $RESULT_LOG" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Scorecard result as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.run-score.outputs.artifact_name }}
          path: |
            ${{ steps.run-score.outputs.result_file }}
            ossf-scorecard-output/scorecard_${{ steps.set-id.outputs.id }}.log
            ossf-scorecard-output/scorecard_${{ steps.set-id.outputs.id }}.stderr.log

      - name: Get artifact download URL
        id: get-artifact-url
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Ensure jq and curl are available
          sudo apt-get update && sudo apt-get install -y jq curl

          ARTIFACT_NAME="${{ steps.run-score.outputs.artifact_name }}"
          echo "Looking up artifact named: $ARTIFACT_NAME"

          RESP=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/artifacts")
          DOWNLOAD_URL=$(echo "$RESP" | jq -r --arg name "$ARTIFACT_NAME" '.artifacts[] | select(.name==$name) | .archive_download_url' | head -n1)

          if [ -n "$DOWNLOAD_URL" ] && [ "$DOWNLOAD_URL" != "null" ]; then
            echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
            mkdir -p ossf-scorecard-output
            echo "$DOWNLOAD_URL" > ossf-scorecard-output/artifact_download_url.txt
          else
            echo "download_url=" >> $GITHUB_OUTPUT
            echo "warning: artifact not found in run artifacts" >&2
          fi

      - name: Show short summary
        run: |
          echo "Workflow input run: ${{ steps.set-id.outputs.id }}"
          echo "Artifact: ${{ steps.run-score.outputs.artifact_name }}"
          echo "Artifact URL: ${{ steps.get-artifact-url.outputs.download_url }}"
          echo "Scorecard FileName: ${{ steps.run-score.outputs.result_file}}"
          echo "Aggregate score: ${{ steps.run-score.outputs.aggregate_score }}"
